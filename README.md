# What's this?

This tree is a prototype "what if we recorded debug-info outside of the instruction stream" implementation for exploring the design space. It's based on llvm-15. Caveats:
 * This is _not_ intended to be submitted for review, it's an experiment.
 * We've focused only on dbg.value intrinsics, as they best embody the problem we want to solve.
 * Making the changes ergonomic to pass authors is the priority: there's a lot of design space for dbg.value storage to explore.

## What's the debug program stuff?

We transfer ("inhale") dbg.value intrinsics into a non-Instruction-class data structure, forming the "debug program" of DPValues and DPMarkers. It's effectively a shadow list of DPMarkers for real instructions, and DPValues inbetween them to record what used to be dbg.values. This has a number of properties that are close to the dbg.value implementation, for example the order of consecutive dbg.values is meaningful, and having the "debug program" in a list preserves that. It also has constant-time complexity. Having a lot of extra allocations behind the scenes isn't especially efficient, but that's not the objective at this stage.

The overwhelming objective of this design is to demonstrate that the same information (variable locations) can be preserved through LLVM, producing an identical binary, using only the (relatively small) collection of changes to the instruction API. If those changes are paletable to the wider community, we can think about making this fast too.

## What should I look at?

There are about 200 files changed -- there should be a PR open showing the diff. Observe the (hopefully) low overhead of the changes that are necessary in optimisation passes: some function calls change names, in other scenarios iterators are used to mark the position where an insertion should happen. Consider how invasive this, and whether the extra mental burdern of being aware of these things is a good trade-off for better debug-info management.

In an ideal world we'd prohibit having insertion API calls that take an instruction pointer, forcing the pass author to type out "getIterator()", which necessitates the thought process of "I'm changing an instruction into a position in the block". That would be a great way of using type safety to mandate some decision making. On the other hand: it would be verbose, which no-one wants. Some significant unanswered questions are "how many debug-info faults are caused by using the wrong insertion method", "how damaging is that to the user experience" and "can we easily discover those scenarios through testing".

In the same vein, we've removed the "moveBefore" method and mandated that moveBeforeBreaking or moveBeforePreserving is used, thus requiring pass authors to explicitly consider whether their instruction moving breaks the control-flow order of instructions, or preserves it. Maybe it's alright to just leave a plain moveBefore alias for moveBeforeBreaking -- we think explicit is better than implicit right now.

## Tell me about the shortcuts and long tail of ugly parts

If you insist. Here's a list of weirdnesses in our changes for future addressing, or if you spot something strange and wonder why. Plus, three or four scenarios where we haven't fully replicated the behaviour of dbg.values as it'd be labour intensive and won't shed any light on the API problems we want to address:
 * There are numerous places where calls to getNextNonDebugInstruction or similar are added -- this is because we've run into every single "-g affects codegen" bug in this process.
 * In 5-10 places we've replaced getFirstNonPHI with getFirstNonPHIOrDbg out of sheer lazyness. This makes the debug-info generated by this tree different from normal llvm-15, the former behaviour can be recovered through using getFirstInsertionPt and having the receiver of the position take an iterator
 * MergeICmps: the doesOtherWork method has a debug-info-affects-codegen issue in it, where dbg.values are seen as "other work" that justifies creating a new block and having instructions hoisted into it before icmps are merged. By complete fluke, in the examples I've seen, they all produce the same code as before (with -g and without), but I don't believe that's guaranteed. This is a scenario where we would need extra special-casing for DPValues -- special casing that should already exist for dbg.values too. In our persuit of an identical binary, we've made both modes (dbg.value and "inhaled") drop debug-info, until we write that special casing.
 * CodeGenPrepare: this pass speculatively starts making changes in a transaction manager, that then get rolled back if they're not going to work out. Unfortuantely, that's anathema to the DPValue design, as removing instructions at some position is going to mean coalescing all the DPValues nearby together, but if that gets rolled back then they will need to be peeled apart. It's not impossible, but we're not going to bother labouring on that when the design is very likely to change again.
 * SimplifyCFG HoistThenElseCodeToIf -- this pairs up dbg.values from either side of the if/else and joins them into the hoisted block. This can be done with DPValues, but is fiddly, so we haven't bothered yet.
 * removeRedundantDbgInstrsUsingBackwardScan exhales dbg.values, runs, and then inhales back to DPValues. We could re-implement this to work on DPValues easily, but haven't bothered yet.
 * CloneFunction and LoopRotationUtils call a method called cloneAndRemapDPValues: because they optimise instructions at the same time as they clone them into new locations, it's especially horrible to maintain debug-info. This isn't a common code pattern, but will inevitably require more instrumentation for DPValues versus using dbg.value intrinsics.
 * LoopRotationUtils also contains some extra special-cases because it hoists instructions as well as just cloning them.
 * We skipped re-implementing replaceDbgValueForAlloca to use DPValues, it's very clear how this would be achieved, but it's used so rarely it didn't seem important right now.
 * In LoopStrengthReduce we've also skipped salvaging of Values into DIArgLists -- there's a reasonably large block of code to clone and re-implement with DPValues. Again, not impossible to re-implement, but it doesn't tell us anything about debug-info maintenence in the rest of LLVM.
